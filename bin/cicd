#!/usr/bin/env node

const { Pipeline, Stage } = require('..');
const debug = require('debug')('cicd:bin');
const { sprintf } = require('sprintf-js');
const yaml = require('js-yaml');
const { Docker } = require('../lib/docker');
const { Compose } = require('../lib/compose');
const argv = require('minimist')(process.argv.slice(2));

const FNS = {
  help () {
    const data = `
CI/CD Command Line Interpreter

Usage: cicd [COMMAND] [OPTIONS]

Commands:
  abort   [STAGE]  Abort pipeline (all stages) or single stage
  dump             Dump pipeline configuration
  help             Print help
  info             Print system information
  ls               List pipeline stages
  run     [STAGE]  Run pipeline (all stages) or single stage
  version          Print version information

Options:
  -h, --help       Print help
  -p, --pull       Force pull base images
  -v, --version    Print version information
    `.trim();
    console.info(data);
  },

  version () {
    const pkgJson = require('../package.json');
    const data = `
cicd version ${pkgJson.version}
    `.trim();
    console.info(data);
  },

  async run (pipeline, name) {
    if (name) {
      await pipeline.getStage(name).run({ env: process.env, logger });
    } else {
      await pipeline.run({ env: process.env, logger });
    }
  },

  async abort (pipeline, name) {
    if (name) {
      await pipeline.getStage(name).abort({ env: process.env, logger });
    } else {
      await pipeline.abort({ env: process.env, logger });
    }
  },

  ls (pipeline) {
    const line = sprintf('%-15s %-15s %s', 'STAGE', 'TYPE', 'DETACHED');
    console.info(line);
    for (const name in pipeline.stages) {
      const stage = pipeline.stages[name];
      const line = sprintf('%-15s %-15s %s', stage.name, stage.type, stage.detach ? 'yes' : 'no');
      console.info(line);
    }
  },

  dump (pipeline) {
    console.info(yaml.dump(pipeline.dump()));
    process.exit();
  },

  async info () {
    console.info('Installed resolvers:');
    Pipeline.RESOLVERS.forEach(resolver => {
      console.info('  -', resolver.name);
    });

    console.info('');
    console.info('Installed adapters:');
    Stage.ADAPTERS.forEach(adapter => {
      console.info('  -', adapter.type);
    });

    console.info('');
    console.info('Versions:');
    console.info('  docker        ', await Docker.version());
    console.info('  docker-compose', await Compose.version());
  },
};

function logger (log) {
  const { pipeline, stage = '', level, message } = log;
  if (level !== 'head' && stage) {
    console.info(sprintf('  --> %-5s %s', level.toUpperCase(), message));
  } else {
    const line = sprintf('[%-16s] %s', `${pipeline}:${stage}`, message);
    if (level === 'warn' || level === 'error') {
      console.error(line);
    } else {
      console.info(line);
    }
  }
}

function getFn (argv) {
  if (argv.v || argv.version) {
    return FNS.version;
  }

  if (argv.h || argv.help) {
    return FNS.help;
  }

  return FNS[argv._[0]];
}

// const argv = process.argv.splice(2);

process.on('SIGINT', () => {
  console.info('');
  console.info('Gracefully shutting down from SIGINT (Ctrl-C)');
});

(async () => {
  try {
    const fn = getFn(argv);
    if (!fn) {
      throw new Error('Command not found!');
    }

    if (argv.p || argv.pull) {
      Docker.reset({ pull: true });
      Compose.reset({ pull: true });
    }

    const pipeline = await Pipeline.resolve(process.cwd());
    await fn(pipeline, ...argv._.slice(1));
    console.info('');
    console.info(':)');
  } catch (err) {
    FNS.help();

    console.error('');
    console.error('Error:', err.message);
    debug(err);
    console.error('');
    console.error(':(');

    process.exit(1);
  }
})();

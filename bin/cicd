#!/usr/bin/env node

const { Pipeline } = require('..');
const debug = require('debug')('cicd:bin');
const { sprintf } = require('sprintf-js');
const yaml = require('js-yaml');

const FNS = {
  help () {
    const data = `
CI/CD Command Line Interpreter

Usage: cicd [OPTIONS] COMMAND

Options:
  -h, --help       Print help
  -v, --version    Print version information

Commands:
  abort   [STAGE]  Abort pipeline (all stages) or single stage
  dump             Dump pipeline configuration
  help             Print help
  ls               List pipeline stages
  run     [STAGE]  Run pipeline (all stages) or single stage
  version          Print version information
    `.trim();
    console.info(data);
  },

  version () {
    const pkgJson = require('../package.json');
    const data = `
cicd version ${pkgJson.version}
    `.trim();
    console.info(data);
  },

  async run (pipeline, name) {
    if (name) {
      await pipeline.getStage(name).run({ env: process.env, logger });
    } else {
      await pipeline.run({ env: process.env, logger });
    }
  },

  async abort (pipeline, name) {
    if (name) {
      await pipeline.getStage(name).abort({ env: process.env, logger });
    } else {
      await pipeline.abort({ env: process.env, logger });
    }
  },

  ls (pipeline) {
    const line = sprintf('%-15s %-15s %s', 'STAGE', 'TYPE', 'DETACHED');
    console.info(line);
    for (const name in pipeline.stages) {
      const stage = pipeline.stages[name];
      const line = sprintf('%-15s %-15s %s', stage.name, stage.type, stage.detach ? 'yes' : 'no');
      console.info(line);
    }
  },

  dump (pipeline) {
    console.info(yaml.dump(pipeline.dump()));
    process.exit();
  },
};

const ALIASES = {
  '-v': 'version',
  '--version': 'version',
  '-h': 'help',
  '--help': 'help',
};

function logger (log) {
  const { pipeline, stage = '', level, message } = log;
  if (level !== 'head' && stage) {
    console.info(sprintf('  --> %-5s %s', level.toUpperCase(), message));
  } else {
    const line = sprintf('[%-16s] %s', `${pipeline}:${stage}`, message);
    if (level === 'warn' || level === 'error') {
      console.error(line);
    } else {
      console.info(line);
    }
  }
}

function getFn (cmd) {
  let fn = FNS[cmd];
  if (!fn) {
    cmd = ALIASES[cmd];
    fn = FNS[cmd];
  }

  return fn;
}

const argv = process.argv.splice(2);

process.on('SIGINT', () => {
  console.info('');
  console.info('Gracefully shutting down from SIGINT (Ctrl-C)');
});

(async () => {
  try {
    const fn = getFn(argv[0]);
    if (!fn) {
      throw new Error('Command not found!');
    }

    const pipeline = await Pipeline.resolve(process.cwd());
    await fn(pipeline, ...argv.slice(1));
    console.info('');
    console.info(':)');
  } catch (err) {
    FNS.help();

    console.error('');
    console.error('Error:', err.message);
    debug(err);
    console.error('');
    console.error(':(');

    process.exit(1);
  }
})();
